/**
 * Word document generator service
 * Uses docx library to create .docx files from markdown content
 */
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, AlignmentType, BorderStyle } from 'docx';
import { DocumentOptions, createSafeFilename, parseMarkdownTable, PIRAMAL_COLORS } from './documentUtils';

/**
 * Generate a Word document from markdown content
 */
export const generateWordDocument = async (options: DocumentOptions): Promise<void> => {
  const { title, companyName, content, includeTimestamp = true, includePageNumbers = true } = options;
  
  // Parse markdown content into document structure
  const docElements = parseMarkdownToDocElements(content);
  
  // Create document with Piramal Finance styling
  const doc = new Document({
    title: title,
    description: `Market Scan Report for ${companyName}`,
    styles: {
      paragraphStyles: [
        {
          id: 'Title',
          name: 'Title',
          run: {
            color: PIRAMAL_COLORS.blue,
            size: 36, // 18pt
            bold: true,
          },
          paragraph: {
            spacing: {
              after: 200,
            },
          },
        },
        {
          id: 'Heading1',
          name: 'Heading 1',
          run: {
            color: PIRAMAL_COLORS.blue,
            size: 32, // 16pt
            bold: true,
          },
          paragraph: {
            spacing: {
              before: 240,
              after: 120,
            },
          },
        },
        {
          id: 'Heading2',
          name: 'Heading 2',
          run: {
            color: PIRAMAL_COLORS.blueLight,
            size: 28, // 14pt
            bold: true,
          },
          paragraph: {
            spacing: {
              before: 240,
              after: 120,
            },
          },
        },
        {
          id: 'Normal',
          name: 'Normal',
          run: {
            color: PIRAMAL_COLORS.textPrimary,
            size: 24, // 12pt
          },
          paragraph: {
            spacing: {
              before: 120,
              after: 120,
            },
          },
        },
      ],
    },
    sections: [
      {
        properties: {
          page: {
            margin: {
              top: 1000, // 1 inch
              right: 1000,
              bottom: 1000,
              left: 1000,
            },
          },
        },
        children: [
          // Add title
          new Paragraph({
            text: title,
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
          }),
          
          // Add subtitle with company name
          new Paragraph({
            alignment: AlignmentType.CENTER,
            children: [
              new TextRun({
                text: `Market Scan Report: ${companyName}`,
                bold: true,
                size: 26, // 13pt
                color: PIRAMAL_COLORS.blueLight,
              }),
            ],
          }),
          
          // Add timestamp if requested
          ...(includeTimestamp 
            ? [new Paragraph({
                alignment: AlignmentType.CENTER,
                children: [
                  new TextRun({
                    text: `Generated on ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}`,
                    size: 20, // 10pt
                    color: PIRAMAL_COLORS.textSecondary,
                  }),
                ],
              })]
            : []),
          
          // Add spacing after header
          new Paragraph({
            text: '',
            spacing: {
              after: 400, // 0.4 inches
            },
          }),
          
          // Add main content elements
          ...docElements,
          
          // Add footer
          new Paragraph({
            text: '',
            spacing: {
              before: 400, // 0.4 inches
            },
          }),
          new Paragraph({
            children: [
              new TextRun({
                text: 'Generated by CMML Research Platform - Piramal Finance',
                size: 18, // 9pt
                color: PIRAMAL_COLORS.textSecondary,
                italics: true,
              }),
            ],
            alignment: AlignmentType.CENTER,
            border: {
              top: {
                color: PIRAMAL_COLORS.blueLight,
                style: BorderStyle.SINGLE,
                size: 1,
              },
            },
            spacing: {
              before: 100, // 0.1 inches
            },
          }),
        ],
      },
    ],
  });

  // Generate and save the document - use Blob directly for browser environments
  const blob = await Packer.toBlob(doc);
  
  // Create filename and trigger download
  const filename = createSafeFilename(companyName, 'docx');
  
  // Use download attribute to save file
  const link = document.createElement('a');
  link.href = window.URL.createObjectURL(blob);
  link.download = filename;
  link.click();
  
  // Clean up
  window.URL.revokeObjectURL(link.href);
};

/**
 * Parse markdown content into docx document elements
 */
const parseMarkdownToDocElements = (markdownContent: string): any[] => {
  const elements: any[] = [];
  const lines = markdownContent.split('\n');
  
  let inTable = false;
  let tableLines: string[] = [];
  let inCodeBlock = false;
  let codeBlockLines: string[] = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Handle code blocks
    if (line.trim().startsWith('```')) {
      if (inCodeBlock) {
        // End of code block
        elements.push(
          new Paragraph({
            children: [
              new TextRun({
                text: codeBlockLines.join('\n'),
                font: 'Courier New',
                size: 20, // 10pt
              }),
            ],
            spacing: {
              before: 120,
              after: 120,
            },
            shading: {
              type: 'clear',
              fill: 'F5F5F5',
            },
          })
        );
        codeBlockLines = [];
        inCodeBlock = false;
      } else {
        // Start of code block
        inCodeBlock = true;
      }
      continue;
    }
    
    if (inCodeBlock) {
      codeBlockLines.push(line);
      continue;
    }
    
    // Handle tables
    if (line.includes('|') && (line.trim().startsWith('|') || line.trim().endsWith('|'))) {
      if (!inTable) {
        inTable = true;
      }
      tableLines.push(line);
      
      // Check if this might be the end of the table (next line is empty or doesn't contain |)
      if (i === lines.length - 1 || !lines[i + 1].includes('|')) {
        // Process table
        const tableElement = createTableElement(tableLines);
        if (tableElement) {
          elements.push(tableElement);
        }
        tableLines = [];
        inTable = false;
      }
      
      continue;
    }
    
    // Handle headers
    if (line.startsWith('# ')) {
      elements.push(
        new Paragraph({
          text: line.replace('# ', ''),
          heading: HeadingLevel.HEADING_1,
        })
      );
      continue;
    }
    
    if (line.startsWith('## ')) {
      elements.push(
        new Paragraph({
          text: line.replace('## ', ''),
          heading: HeadingLevel.HEADING_2,
        })
      );
      continue;
    }
    
    if (line.startsWith('### ')) {
      elements.push(
        new Paragraph({
          text: line.replace('### ', ''),
          heading: HeadingLevel.HEADING_3,
        })
      );
      continue;
    }
    
    // Handle horizontal rule
    if (line.trim() === '---') {
      elements.push(
        new Paragraph({
          text: '',
          border: {
            bottom: {
              color: PIRAMAL_COLORS.blueLight,
              style: BorderStyle.SINGLE,
              size: 1,
            },
          },
          spacing: {
            before: 120,
            after: 120,
          },
        })
      );
      continue;
    }
    
    // Handle bold/italic within paragraphs
    if (line.trim()) {
      const paragraph = new Paragraph({
        children: formatTextRuns(line),
      });
      elements.push(paragraph);
    } else {
      // Empty line
      elements.push(new Paragraph({ text: '' }));
    }
  }
  
  return elements;
};

/**
 * Create a Word table element from markdown table lines
 */
const createTableElement = (tableLines: string[]): Table | null => {
  if (tableLines.length < 3) {
    return null;
  }
  
  // Parse table data
  const { headers, rows } = parseMarkdownTable(tableLines.join('\n'));
  
  if (headers.length === 0) {
    return null;
  }
  
  // Create table rows
  const tableRows: TableRow[] = [];
  
  // Header row
  tableRows.push(
    new TableRow({
      children: headers.map(header => 
        new TableCell({
          children: [new Paragraph({ text: header })],
          shading: {
            fill: PIRAMAL_COLORS.blueLighter,
          },
        })
      ),
    })
  );
  
  // Data rows
  rows.forEach(row => {
    tableRows.push(
      new TableRow({
        children: row.map(cell => 
          new TableCell({
            children: [new Paragraph({ text: cell })],
          })
        ),
      })
    );
  });
  
  // Create table
  return new Table({
    rows: tableRows,
    width: {
      size: 100,
      type: 'pct',
    },
  });
};

/**
 * Format text with bold/italic/etc based on markdown formatting
 */
const formatTextRuns = (text: string): TextRun[] => {
  // This is a simplified approach - for production, consider a proper markdown parser
  // that can handle nested formatting and other complex cases
  
  const runs: TextRun[] = [];
  
  // Simple regex-based formatting
  // Bold
  text = text.replace(/\*\*([^*]+)\*\*/g, (match, content) => {
    runs.push(new TextRun({ text: content, bold: true }));
    return '[FORMATTED]';
  });
  
  // Italic
  text = text.replace(/\*([^*]+)\*/g, (match, content) => {
    runs.push(new TextRun({ text: content, italics: true }));
    return '[FORMATTED]';
  });
  
  // Process remaining text
  let remainingText = '';
  const parts = text.split('[FORMATTED]');
  
  parts.forEach((part, index) => {
    if (part) {
      runs.push(new TextRun({ text: part }));
    }
  });
  
  return runs.length > 0 ? runs : [new TextRun({ text })];
};

export default {
  generateWordDocument,
};
